#include "threads.h"
#include "sem.h"
#include <stdio.h>
#include <stdlib.h>

int bufferSize;
int producersNum;
int consumersNum;
int numRun;
int processIDLines;
int *buffer;
int in = 0;
int out = 0;
struct TCB_t *RunQ;
struct semaphore *empty;
struct semaphore *full;

// Buffer should hold producerID
void producer(int producerID){
    // Initialize local variables
    int item = 1;   // Each producer starts by producing item 1

    // While loop for producing
    while(item <= numRun){
        
        if (empty->value <= 0){
            while (empty->value <= 0){
                printf("\n Producer %d is waiting \n",producerID);
                P(empty);
                // End loop when RunQ is empty to prevent segmentation fault
                if (RunQ == NULL){
                    return;
                }
            }
        }
        
        if(empty->value > 0){
            P(empty);    // Decrement empty->value, then block once at 0
            printf("\n Producer %d is producing item number %d \n",producerID,item);
            buffer[in] = producerID;
            in = (in + 1) % bufferSize;
            V(full, numRun, item);     // Increment full->value, and unblock once greater than 0
        } 
        item++;   
    }
}

void consumer(int consumerID){
    // Initialize local variables
    int timesRun = 1;
    int item;

    // While loop for consuming
    while(timesRun <= numRun){   
         
        if (full->value <= 0){
            while (full->value <= 0){
                printf("\n Consumer %d is waiting \n",consumerID);
                P(full);
                // End loop when RunQ is empty to prevent segmentation fault
                if (RunQ == NULL){
                    return;
                }
            }
        }

        if (full->value > 0){
            P(full);   // Decrement full->value, then block once at 0
            item = buffer[out];
            printf("\n Consumer %d is consuming item generated by Producer %d \n",consumerID,item);
            out = (out + 1) % bufferSize;
            V(empty, numRun, timesRun);  // Increment empty->value, then unblock once greater then 0
        }
        timesRun++;
    } 
}

int main(){
    // Read in first 4 variables
    scanf("%d,%d,%d,%d", &bufferSize, &producersNum, &consumersNum, &numRun);
    processIDLines = producersNum + consumersNum;

    // Allocate memory
    buffer = (int*)malloc(sizeof(int) *bufferSize); 
    RunQ = (TCB_t*)malloc(sizeof(TCB_t));
    empty = (struct semaphore *)malloc(sizeof(struct semaphore));
    full = (struct semaphore *)malloc(sizeof(struct semaphore));

    // Initialize data structures
    InitQueue(&RunQ);
    InitSem(empty, bufferSize);
    InitSem(full, 0);

    // Read in threadIDs
    int j = 0;
    int input;
    while(j < processIDLines){
        scanf("%d", &input);
        if (input < 0){
            input = input * -1;
            start_thread(consumer, input);
        } else {
            start_thread(producer, input);
        }
        j++;
    }
    run();
}